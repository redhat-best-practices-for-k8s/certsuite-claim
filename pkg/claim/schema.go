// Copyright (C) 2020 Red Hat, Inc.
//
// This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
// License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later
// version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along with this program; if not, write to the Free
// Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

//
// Code generated by `test-network-function-claim/cmd/generate/generate.go` on: 2020-10-30 15:09:05.998917 -0400 EDT m=+0.001369644
//
// `https://github.com/a-h/generate` provides a generic set of interfaces to convert JSON schema into
// workable GoLang struct implementations.  However, the code generator is limited and does not allow
// type remapping.  By default, JSON Schema "object" types are remapped to custom struct definitions.
// This becomes a problem in our case, as we do not define certain facets such as "Hosts" or
// "LshwOutput".  This CLI driven generator augments the stock generator to allow overrides to generic
// "map[string]interface{}", which is capable of representing arbitrary JSON data.
//
// Warning:  Do not edit this file by hand.  Instead, use Makefile targets.
//

// Code generated by schema-generate. DO NOT EDIT.

package claim

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

// Claim
type Claim struct {

	// The claim evaluation end time.
	EndTime string `json:"endTime"`

	// Hostname/payload key/value information for all hosts in the cluster.
	Hosts *Hosts `json:"hosts"`

	// JUnit test results.
	JunitResults map[string]interface{} `json:"junitResults"`

	// The claim evaluation start time.
	StartTime string `json:"startTime"`

	// The key/value configuration data to perform the given claim tests.
	TestConfigurations map[string]interface{} `json:"testConfigurations"`

	// The test-network-function (tnf) commit hash.
	TnfVersion string `json:"tnfVersion"`
}

// Hosts Hostname/payload key/value information for all hosts in the cluster.
type Hosts struct {

	// A description of a host using the Unix lshw command.
	LshwOutput map[string]interface{} `json:"lshwOutput,omitempty"`
}

// Root Represents a test-network-function claim.
type Root struct {
	Claim *Claim `json:"claim,omitempty"`
}

func (strct *Claim) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "EndTime" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "endTime" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"endTime\": ")
	if tmp, err := json.Marshal(strct.EndTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Hosts" field is required
	if strct.Hosts == nil {
		return nil, errors.New("hosts is a required field")
	}
	// Marshal the "hosts" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"hosts\": ")
	if tmp, err := json.Marshal(strct.Hosts); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "JunitResults" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "junitResults" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"junitResults\": ")
	if tmp, err := json.Marshal(strct.JunitResults); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "StartTime" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "startTime" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"startTime\": ")
	if tmp, err := json.Marshal(strct.StartTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "TestConfigurations" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "testConfigurations" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"testConfigurations\": ")
	if tmp, err := json.Marshal(strct.TestConfigurations); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "TnfVersion" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "tnfVersion" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"tnfVersion\": ")
	if tmp, err := json.Marshal(strct.TnfVersion); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Claim) UnmarshalJSON(b []byte) error {
	endTimeReceived := false
	hostsReceived := false
	junitResultsReceived := false
	startTimeReceived := false
	testConfigurationsReceived := false
	tnfVersionReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "endTime":
			if err := json.Unmarshal([]byte(v), &strct.EndTime); err != nil {
				return err
			}
			endTimeReceived = true
		case "hosts":
			if err := json.Unmarshal([]byte(v), &strct.Hosts); err != nil {
				return err
			}
			hostsReceived = true
		case "junitResults":
			if err := json.Unmarshal([]byte(v), &strct.JunitResults); err != nil {
				return err
			}
			junitResultsReceived = true
		case "startTime":
			if err := json.Unmarshal([]byte(v), &strct.StartTime); err != nil {
				return err
			}
			startTimeReceived = true
		case "testConfigurations":
			if err := json.Unmarshal([]byte(v), &strct.TestConfigurations); err != nil {
				return err
			}
			testConfigurationsReceived = true
		case "tnfVersion":
			if err := json.Unmarshal([]byte(v), &strct.TnfVersion); err != nil {
				return err
			}
			tnfVersionReceived = true
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	// check if endTime (a required property) was received
	if !endTimeReceived {
		return errors.New("\"endTime\" is required but was not present")
	}
	// check if hosts (a required property) was received
	if !hostsReceived {
		return errors.New("\"hosts\" is required but was not present")
	}
	// check if junitResults (a required property) was received
	if !junitResultsReceived {
		return errors.New("\"junitResults\" is required but was not present")
	}
	// check if startTime (a required property) was received
	if !startTimeReceived {
		return errors.New("\"startTime\" is required but was not present")
	}
	// check if testConfigurations (a required property) was received
	if !testConfigurationsReceived {
		return errors.New("\"testConfigurations\" is required but was not present")
	}
	// check if tnfVersion (a required property) was received
	if !tnfVersionReceived {
		return errors.New("\"tnfVersion\" is required but was not present")
	}
	return nil
}

func (strct *Root) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "claim" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"claim\": ")
	if tmp, err := json.Marshal(strct.Claim); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Root) UnmarshalJSON(b []byte) error {
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "claim":
			if err := json.Unmarshal([]byte(v), &strct.Claim); err != nil {
				return err
			}
		default:
			return fmt.Errorf("additional property not allowed: \"" + k + "\"")
		}
	}
	return nil
}
